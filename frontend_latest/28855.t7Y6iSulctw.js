export const id=28855;export const ids=[28855];export const modules={10469:(e,t,o)=>{o.d(t,{$:()=>n});o(89655);const n=(e,t)=>{const o={};for(const n of e){const e=t(n);e in o?o[e].push(n):o[e]=[n]}return o}},47076:(e,t,o)=>{o.a(e,(async(e,n)=>{try{o.d(t,{AN:()=>F,B2:()=>$,BV:()=>S,DR:()=>X,E$:()=>H,GW:()=>M,KJ:()=>R,Q4:()=>z,RB:()=>T,WN:()=>P,X4:()=>I,_d:()=>N,al:()=>B,bs:()=>C,c:()=>E,gv:()=>K,m7:()=>x,oU:()=>W,tb:()=>V,uh:()=>D,yM:()=>Z});o(89655),o(253),o(54846),o(16891);var r=o(31195),s=o(77301),a=o(91103),i=o(39902),c=o(72730),l=o(61310),g=o(31293),u=o(63165),_=o(60132),f=o(83324),d=o(84280),y=o(94100),h=o(78691),m=o(41924),p=o(10469),v=o(31265),b=o(4826),w=e([h,m]);[h,m]=w.then?(await w)():w;const k=[],x=()=>({stat_energy_from:"",stat_cost:null,entity_energy_price:null,number_energy_price:null}),T=()=>({stat_energy_to:"",stat_compensation:null,entity_energy_price:null,number_energy_price:null}),D=()=>({type:"grid",flow_from:[],flow_to:[],cost_adjustment_day:0}),z=()=>({type:"solar",stat_energy_from:"",config_entry_solar_forecast:null}),W=()=>({type:"battery",stat_energy_from:"",stat_energy_to:""}),E=()=>({type:"gas",stat_energy_from:"",stat_cost:null,entity_energy_price:null,number_energy_price:null}),M=()=>({type:"water",stat_energy_from:"",stat_cost:null,entity_energy_price:null,number_energy_price:null}),S=e=>e.callWS({type:"energy/info"}),$=async e=>(await e.loadBackendTranslation("issues","energy"),e.callWS({type:"energy/validate"})),C=e=>e.callWS({type:"energy/get_prefs"}),P=async(e,t)=>{const o=e.callWS({type:"energy/save_prefs",...t});return j(e),o},A=async(e,t,o,n,r,s="hour")=>e.callWS({type:"energy/fossil_energy_consumption",start_time:t.toISOString(),end_time:r?.toISOString(),energy_statistic_ids:o,co2_statistic_id:n,period:s}),H=e=>(0,p.$)(e.energy_sources,(e=>e.type)),F=(e,t,o)=>{const n=[];for(const r of e.energy_sources)if(!o||o.includes(r.type))if("solar"!==r.type)if("gas"!==r.type&&"water"!==r.type)if("battery"!==r.type){for(const e of r.flow_from){n.push(e.stat_energy_from),e.stat_cost&&n.push(e.stat_cost);const o=t.cost_sensors[e.stat_energy_from];o&&n.push(o)}for(const e of r.flow_to){n.push(e.stat_energy_to),e.stat_compensation&&n.push(e.stat_compensation);const o=t.cost_sensors[e.stat_energy_to];o&&n.push(o)}}else n.push(r.stat_energy_from),n.push(r.stat_energy_to);else{n.push(r.stat_energy_from),r.stat_cost&&n.push(r.stat_cost);const e=t.cost_sensors[r.stat_energy_from];e&&n.push(e)}else n.push(r.stat_energy_from);return o&&!o.includes("device")||n.push(...e.device_consumption.map((e=>e.stat_consumption))),n},O=async(e,t,o,n,u)=>{const[_,f]=await Promise.all([(0,v.VN)(e,{domain:"co2signal"}),S(e)]),d=_.length?_[0]:void 0;let y;if(d)for(const t of Object.values(e.entities)){if("co2signal"!==t.platform)continue;const o=e.states[t.entity_id];if(o&&"%"===o.attributes.unit_of_measurement){y=o.entity_id;break}}const m=[];for(const e of t.energy_sources)if("grid"===e.type)for(const t of e.flow_from)m.push(t.stat_energy_from);const p=F(t,f,["grid","solar","battery","gas","device"]),w=F(t,f,["water"]),k=[...p,...w],x=(0,r.c)(n||new Date,o),T=x>35?"month":x>2?"day":"hour",D=e.config.unit_system.length||"",z={energy:"kWh",volume:"km"===D?"m続":"ft続"},W={volume:"km"===D?"L":"gal"},E=p.length?(0,b.sz)(e,o,n,p,T,z,["change"]):{},M=w.length?(0,b.sz)(e,o,n,w,T,W,["change"]):{};let $,C,P,H,O,j={},q={};u&&(C=(0,h.xo)(o,s.e,e.locale,e.config)&&(0,h.xo)(n||new Date,a.c,e.locale,e.config)?(0,h.ol)(o,i.P,e.locale,e.config,-(0,h.EO)(n||new Date,o,c.W,e.locale,e.config)-1):(0,h.ol)(o,l.f,e.locale,e.config,-1*(x+1)),P=(0,g.A)(o,-1),p.length&&(j=(0,b.sz)(e,C,P,p,T,z,["change"])),w.length&&(q=(0,b.sz)(e,C,P,w,T,W,["change"]))),void 0!==y&&(H=A(e,o,m,y,n,x>35?"month":x>2?"day":"hour"),u&&(O=A(e,C,m,y,P,x>35?"month":x>2?"day":"hour")));const V={},B=k.length?(0,b.Wr)(e,k):[],[L,N,R,Z,I,K,U]=await Promise.all([E,M,j,q,B,H,O]),X={...L,...N};u&&($={...R,...Z}),k.length&&I.forEach((e=>{V[e.statistic_id]=e}));return{start:o,end:n,startCompare:C,endCompare:P,info:f,prefs:t,stats:X,statsMetadata:V,statsCompare:$,co2SignalConfigEntry:d,co2SignalEntity:y,fossilEnergyConsumption:K,fossilEnergyConsumptionCompare:U}},j=e=>{k.forEach((t=>{const o=V(e,{key:t});o.clearPrefs(),o._active&&o.refresh()}))},q=e=>{if(e._refreshTimeout&&clearTimeout(e._refreshTimeout),e._active&&(!e.end||e.end>new Date)){const t=new Date;t.getMinutes()>=20&&t.setHours(t.getHours()+1),t.setMinutes(20,0,0),e._refreshTimeout=window.setTimeout((()=>e.refresh()),t.getTime()-Date.now())}},V=(e,t={})=>{let o="_energy";if(t.key){if(!t.key.startsWith("energy_"))throw new Error("Key need to start with energy_");o=`_${t.key}`}if(e.connection[o])return e.connection[o];k.push(t.key);const n=(0,d.X)(e.connection,o,(async()=>(n.prefs||(n.prefs=await C(e)),q(n),O(e,n.prefs,n.start,n.end,n.compare)))),r=n.subscribe;n.subscribe=e=>{const t=r(e);return n._active++,void 0===n._refreshTimeout&&q(n),()=>{n._active--,n._active<1&&(clearTimeout(n._refreshTimeout),n._refreshTimeout=void 0),t()}},n._active=0,n.prefs=t.prefs;const s=new Date,a=(0,m.LW)(s,e.locale,e.config).split(":")[0];n.start=(0,h.ol)("0"===a?(0,l.f)(s,-1):s,u.o,e.locale,e.config),n.end=(0,h.ol)("0"===a?(0,l.f)(s,-1):s,_.D,e.locale,e.config);const i=()=>{n._updatePeriodTimeout=window.setTimeout((()=>{n.start=(0,h.ol)(new Date,u.o,e.locale,e.config),n.end=(0,h.ol)(new Date,_.D,e.locale,e.config),i()}),(0,f.L)((0,h.ol)(s,_.D,e.locale,e.config),1).getTime()-Date.now())};return i(),n.clearPrefs=()=>{n.prefs=void 0},n.setPeriod=(t,o)=>{n.start=t,n.end=o,n.start.getTime()!==(0,h.ol)(new Date,u.o,e.locale,e.config).getTime()||n.end?.getTime()!==(0,h.ol)(new Date,_.D,e.locale,e.config).getTime()||n._updatePeriodTimeout?n._updatePeriodTimeout&&(clearTimeout(n._updatePeriodTimeout),n._updatePeriodTimeout=void 0):i()},n.setCompare=e=>{n.compare=e},n},B=e=>e.callWS({type:"energy/solar_forecast"}),L=["volume","energy"],N=(e,t={},o)=>{for(const n of e.energy_sources){if("gas"!==n.type)continue;if(o&&o===n.stat_energy_from)continue;const e=t[n.stat_energy_from];if(L.includes(e?.unit_class))return e.unit_class}},R=(e,t,o={})=>{const n=N(t,o);if(void 0!==n)return"energy"===n?"kWh":"km"===e.config.unit_system.length?"m続":"ft続"},Z=e=>"km"===e.config.unit_system.length?"L":"gal",I="/docs/energy/faq/#troubleshooting-missing-entities",K=(0,y.A)((e=>({summedData:U(e),compareSummedData:e.statsCompare?U(e,!0):void 0}))),U=(e,t)=>{const o={};for(const t of e.prefs.energy_sources)if("solar"!==t.type)if("battery"!==t.type){if("grid"===t.type){for(const e of t.flow_from)o.from_grid?o.from_grid.push(e.stat_energy_from):o.from_grid=[e.stat_energy_from];for(const e of t.flow_to)o.to_grid?o.to_grid.push(e.stat_energy_to):o.to_grid=[e.stat_energy_to]}}else o.to_battery?(o.to_battery.push(t.stat_energy_to),o.from_battery.push(t.stat_energy_from)):(o.to_battery=[t.stat_energy_to],o.from_battery=[t.stat_energy_from]);else o.solar?o.solar.push(t.stat_energy_from):o.solar=[t.stat_energy_from];const n={};return Object.entries(o).forEach((([o,r])=>{const s={},a={};r.forEach((o=>{const n=t?e.statsCompare[o]:e.stats[o];if(!n)return;n.forEach((e=>{if(null===e.change||void 0===e.change)return;const t=e.change;s[e.start]=e.start in s?s[e.start]+t:t})),a[o]={}})),n[o]=s})),n},X=(0,y.A)(((e,t)=>({consumption:Y(e),compareConsumption:t?Y(t):void 0}))),Y=e=>{const t={total:{}};return Object.keys(e).forEach((o=>{Object.keys(e[o]).forEach((o=>{if(void 0===t.total[o]){const n=(e.from_grid?.[o]||0)+(e.solar?.[o]||0)+(e.from_battery?.[o]||0)-(e.to_grid?.[o]||0)-(e.to_battery?.[o]||0);t.total[o]=n}}))})),t};n()}catch(e){n(e)}}))},28855:(e,t,o)=>{o.a(e,(async(e,n)=>{try{o.r(t);var r=o(36312),s=(o(253),o(94438),o(16891),o(7986),o(50289)),a=o(29818),i=o(57636),c=(o(13082),o(43106)),l=(o(88400),o(47076)),g=o(4826),u=o(20712),_=o(7934),f=e([i,c,l]);[i,c,l]=f.then?(await f)():f;const d="M13,9H11V7H13M13,17H11V11H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z",y=[{level:-1,stroke:"var(--energy-grid-consumption-color)"},{level:0,stroke:"var(--energy-grid-return-color)"}];(0,r.A)([(0,a.EM)("hui-energy-grid-neutrality-gauge-card")],(function(e,t){return{F:class extends t{constructor(...t){super(...t),e(this)}},d:[{kind:"field",decorators:[(0,a.MZ)({attribute:!1})],key:"hass",value:void 0},{kind:"field",decorators:[(0,a.wk)()],key:"_config",value:void 0},{kind:"field",decorators:[(0,a.wk)()],key:"_data",value:void 0},{kind:"field",key:"hassSubscribeRequiredHostProps",value:()=>["_config"]},{kind:"method",key:"hassSubscribe",value:function(){return[(0,l.tb)(this.hass,{key:this._config?.collection_key}).subscribe((e=>{this._data=e}))]}},{kind:"method",key:"getCardSize",value:function(){return 4}},{kind:"method",key:"setConfig",value:function(e){this._config=e}},{kind:"method",key:"shouldUpdate",value:function(e){return(0,_.xP)(this,e)||e.size>1||!e.has("hass")}},{kind:"method",key:"render",value:function(){if(!this._config||!this.hass)return s.s6;if(!this._data)return s.qy`${this.hass.localize("ui.panel.lovelace.cards.energy.loading")}`;const e=this._data.prefs.energy_sources.find((e=>"grid"===e.type));let t;if(!e)return s.s6;const o=(0,g.gF)(this._data.stats,e.flow_from.map((e=>e.stat_energy_from))),n=(0,g.gF)(this._data.stats,e.flow_to.map((e=>e.stat_energy_to)));return null!==o&&null!==n&&(t=n>o?1-o/n:n<o?-1*(1-n/o):0),s.qy` <ha-card> ${void 0!==t?s.qy` <ha-svg-icon id="info" .path="${d}"></ha-svg-icon> <simple-tooltip animation-delay="0" for="info" position="left"> <span> ${this.hass.localize("ui.panel.lovelace.cards.energy.grid_neutrality_gauge.energy_dependency")} <br><br> ${this.hass.localize("ui.panel.lovelace.cards.energy.grid_neutrality_gauge.color_explain")} </span> </simple-tooltip> <ha-gauge min="-1" max="1" .value="${t}" .valueText="${(0,i.ZV)(Math.abs(n-o),this.hass.locale,{maximumFractionDigits:2})}" .locale="${this.hass.locale}" .levels="${y}" label="kWh" needle></ha-gauge> <div class="name"> ${n>=o?this.hass.localize("ui.panel.lovelace.cards.energy.grid_neutrality_gauge.net_returned_grid"):this.hass.localize("ui.panel.lovelace.cards.energy.grid_neutrality_gauge.net_consumed_grid")} </div> `:this.hass.localize("ui.panel.lovelace.cards.energy.grid_neutrality_gauge.grid_neutrality_not_calculated")} </ha-card> `}},{kind:"get",static:!0,key:"styles",value:function(){return s.AH`ha-card{height:100%;overflow:hidden;padding:16px;display:flex;align-items:center;justify-content:center;flex-direction:column;box-sizing:border-box}ha-gauge{width:100%;max-width:250px;direction:ltr}.name{text-align:center;line-height:initial;color:var(--primary-text-color);width:100%;font-size:15px;margin-top:8px}ha-svg-icon{position:absolute;right:4px;inset-inline-end:4px;inset-inline-start:initial;top:4px;color:var(--secondary-text-color)}simple-tooltip>span{font-size:12px;line-height:12px}simple-tooltip{width:80%;max-width:250px;top:8px!important}`}}]}}),(0,u.E)(s.WF));n()}catch(e){n(e)}}))},24226:(e,t,o)=>{o.d(t,{z:()=>r});var n=o(30429);function r(e,t){const o=(0,n.a)(e),r=(0,n.a)(t),s=o.getTime()-r.getTime();return s<0?-1:s>0?1:s}},72730:(e,t,o)=>{o.d(t,{W:()=>i});var n=o(24226),r=o(30429);function s(e,t){const o=(0,r.a)(e),n=(0,r.a)(t);return 12*(o.getFullYear()-n.getFullYear())+(o.getMonth()-n.getMonth())}var a=o(91103);function i(e,t){const o=(0,r.a)(e),i=(0,r.a)(t),c=(0,n.z)(o,i),l=Math.abs(s(o,i));let g;if(l<1)g=0;else{1===o.getMonth()&&o.getDate()>27&&o.setDate(30),o.setMonth(o.getMonth()-c*l);let t=(0,n.z)(o,i)===-c;(0,a.c)((0,r.a)(e))&&1===l&&1===(0,n.z)(e,i)&&(t=!1),g=c*(l-Number(t))}return 0===g?0:g}},77301:(e,t,o)=>{o.d(t,{e:()=>r});var n=o(30429);function r(e){return 1===(0,n.a)(e).getDate()}},91103:(e,t,o)=>{o.d(t,{c:()=>a});var n=o(60132),r=o(12152),s=o(30429);function a(e){const t=(0,s.a)(e);return+(0,n.D)(t)==+(0,r.p)(t)}}};
//# sourceMappingURL=28855.t7Y6iSulctw.js.map